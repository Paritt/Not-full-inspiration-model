# -*- coding: utf-8 -*-
"""Copy of CutOff200_Full.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1k5Ld9x4iyujVWc8rP-gXZpu_F1UXhBfP

#**Rib of lung (ROL) of test dataset**
"""

from sklearn.preprocessing import LabelEncoder
from tensorflow.keras.utils import to_categorical
import glob
import cv2
import numpy as np
import os
import statistics
import matplotlib.pyplot as plt

from google.colab import drive
drive.mount('/content/drive')

"""##Function"""

def load_mask(path, n_classes=3, SIZE_Y=512, SIZE_X=512):
  print('Loading in progress...')
  masks_path = []
  masks = []
  for directory_path in glob.glob(path):
    for mask_path in glob.glob(os.path.join(directory_path, "*.tiff")):
        masks_path.append(mask_path)
  masks_path.sort()
  for mask_path in masks_path:
        mask = cv2.imread(mask_path, 0) #Read in grayscale mode (0)       
        mask = cv2.resize(mask, (SIZE_Y, SIZE_X), interpolation = cv2.INTER_NEAREST)  #Otherwise ground truth changes due to interpolation
        masks.append(mask)
  masks = np.array(masks) #Change it to numpy array
  #Encode
  labelencoder = LabelEncoder()
  n, h, w = masks.shape
  masks_reshaped = masks.reshape(-1,1)
  masks_reshaped_encoded = labelencoder.fit_transform(masks_reshaped)
  masks_encoded_original_shape = masks_reshaped_encoded.reshape(n, h, w)
  #Expand dimension
  masks_input = np.expand_dims(masks_encoded_original_shape, axis = 3)
  #One hot encode
  onehot_mask = to_categorical(masks_input,num_classes=n_classes)
  print('Done!')
  print(f'Mask shape: {onehot_mask.shape}')
  return onehot_mask

def dice_cal(y_true, y_pred):
    intersection = np.sum(np.logical_and(y_true, y_pred).astype(float))
    if (np.sum(y_true)==0) and (np.sum(y_pred)==0):
        return 1
    return (2*intersection) / (np.sum(y_true) + np.sum(y_pred))

def Overall_Dice(human_mask, gt_mask, class_dict, n_classes=3):
  dice_class_0 = []
  dice_class_1 = []
  dice_class_2 = []
  for img_num in range(len(human_mask)):
    for i in range(n_classes):
      dice = dice_cal(gt_mask[img_num][:,:,i], human_mask[img_num][:,:,i])
      if i == 0:
        dice_class_0.append(dice)
      elif i == 1:
        dice_class_1.append(dice)
      elif i == 2:
        dice_class_2.append(dice)
  print('\033[1mOverall Dice Score\033[0m')
  mean_dice_class_0 = np.sum(dice_class_0)/len(human_mask)
  mean_dice_class_1 = np.sum(dice_class_1)/len(human_mask)
  mean_dice_class_2 = np.sum(dice_class_2)/len(human_mask)
  overall_dice = (mean_dice_class_0 + mean_dice_class_1 + mean_dice_class_2)/n_classes
  print(f'{class_dict[0]}: {round(mean_dice_class_0,3)}')
  print(f'{class_dict[1]}: {round(mean_dice_class_1,3)}')
  print(f'{class_dict[2]}: {round(mean_dice_class_2,3)}')
  print(f'All classes: {round(overall_dice,3)}\n')

def majority(h1,h2,h3,img_num=0):
  for i in range(3):
    if i == 0:
      h1orh2 = np.logical_or(h1[img_num][:,:,i], h2[img_num][:,:,i]).astype(float)
      h1orh3 = np.logical_or(h1[img_num][:,:,i], h3[img_num][:,:,i]).astype(float)
      h2orh3 = np.logical_or(h2[img_num][:,:,i], h3[img_num][:,:,i]).astype(float)
      and1 = np.logical_and(h1orh2, h1orh3).astype(float)
      gt = np.logical_and(h2orh3, and1).astype(float)
    else:
      h1orh2 = np.logical_or(h1[img_num][:,:,i], h2[img_num][:,:,i]).astype(float)
      h1orh3 = np.logical_or(h1[img_num][:,:,i], h3[img_num][:,:,i]).astype(float)
      h2orh3 = np.logical_or(h2[img_num][:,:,i], h3[img_num][:,:,i]).astype(float)
      and1 = np.logical_and(h1orh2, h1orh3).astype(float)
      and2 = np.logical_and(h2orh3, and1).astype(float)
      gt = np.dstack((gt, and2))
  return gt

def create_gt(h1,h2,h3):
  print('Processing...')
  for img_num in range(len(h1)):
    if img_num == 0:
      gt = majority(h1,h2,h3,img_num=img_num)
    elif img_num == 1:
      gt_inter = majority(h1,h2,h3,img_num=img_num)
      gt = np.stack((gt, gt_inter))
    else:
      gt_inter = majority(h1,h2,h3,img_num=img_num)
      gt_inter = np.expand_dims(gt_inter, axis = 0)
      gt = np.concatenate((gt, gt_inter))
  print('Done!')
  print(f'GT shape: {gt.shape}')
  return gt

def cal_intersec(rib,lung,index2):
  z = rib[index2]*lung[index2]
  intersec = np.count_nonzero(z > 0)
  union = np.count_nonzero(rib[index2] == 1) + np.count_nonzero(rib[index2] == 2)
  iou = intersec/union * 100
  return iou

def Average(lst):
    return sum(lst) / len(lst)

def read_in_folder(path):
  masks_path = [] 
  masks = [] 
  for directory_path in glob.glob(path):
      for mask_path in glob.glob(os.path.join(directory_path, "*.tiff")):
          masks_path.append(mask_path)
  masks_path.sort()
  for mask_path in masks_path:
          mask = cv2.imread(mask_path, 0) #Read in grayscale mode (0)       
          mask = cv2.resize(mask, (512, 512), interpolation = cv2.INTER_NEAREST)  #Otherwise ground truth changes due to interpolation
          masks.append(mask)
  masks = np.array(masks) #Change it to numpy array
  print(masks_path)
  return masks

def read_img_in_folder(path):
  masks_path = [] 
  masks = [] 
  for directory_path in glob.glob(path):
      for mask_path in glob.glob(os.path.join(directory_path, "*.png")):
          masks_path.append(mask_path)
  masks_path.sort()
  for mask_path in masks_path:
          mask = cv2.imread(mask_path, 0) #Read in grayscale mode (0)       
          mask = cv2.resize(mask, (512, 512), interpolation = cv2.INTER_NEAREST)  #Otherwise ground truth changes due to interpolation
          masks.append(mask)
  masks = np.array(masks) #Change it to numpy array
  print(masks_path)
  return masks

"""##Load mask"""

h1_path_l = '/content/drive/Shareddrives/CXR_Project/Code/Colab_Notebook/Full Inspired/TEST200_Cutoff/Earn/Lung/Not Full'
h2_path_l = '/content/drive/Shareddrives/CXR_Project/Code/Colab_Notebook/Full Inspired/TEST200_Cutoff/Myu/Lung/Not Full'
h3_path_l = '/content/drive/Shareddrives/CXR_Project/Code/Colab_Notebook/Full Inspired/TEST200_Cutoff/Boo/Lung/Not Full'

h1_path_r = '/content/drive/Shareddrives/CXR_Project/Code/Colab_Notebook/Full Inspired/TEST200_Cutoff/Earn/Rib/Not Full'
h2_path_r = '/content/drive/Shareddrives/CXR_Project/Code/Colab_Notebook/Full Inspired/TEST200_Cutoff/Myu/Rib/Not Full'
h3_path_r = '/content/drive/Shareddrives/CXR_Project/Code/Colab_Notebook/Full Inspired/TEST200_Cutoff/Boo/Rib/Not Full'

h1_l = load_mask(h1_path_l)
h2_l = load_mask(h2_path_l)
h3_l = load_mask(h3_path_l)

h1_r = load_mask(h1_path_r)
h2_r = load_mask(h2_path_r)
h3_r = load_mask(h3_path_r)

"""##Create GT"""

gt_l = create_gt(h1_l,h2_l,h3_l)
gt_r = create_gt(h1_r,h2_r,h3_r)

gt_l = np.argmax(gt_l, axis=3)
gt_r = np.argmax(gt_r, axis=3)
print(gt_l.shape)
print(gt_r.shape)

"""##Calculate intersection"""

all_inter = []
for i in range(gt_r.shape[0]):
  inter = cal_intersec(gt_r,gt_l,i)
  all_inter.append(inter)

"""##Report"""

print(f'Min: {min(all_inter)}')
print(f'Max: {max(all_inter)}')
print(f'Average: {Average(all_inter)}')
print(f'SD: {statistics.stdev(all_inter)}')

for i in range(len(all_inter)):
  print(all_inter[i])