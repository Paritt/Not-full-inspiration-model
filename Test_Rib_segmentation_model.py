# -*- coding: utf-8 -*-
"""245 of Test_model .ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/18DhjBiMtZOxvVSek-Pu6avouGj0AFYDQ

##**Test model**
"""

pip install -U segmentation-models

from sklearn.preprocessing import LabelEncoder
from tensorflow.keras.utils import to_categorical
import glob
import cv2
import numpy as np
import os
import matplotlib.pyplot as plt
import tensorflow as tf
import keras 
from sklearn.preprocessing import LabelEncoder
from keras.utils.all_utils import normalize 
from keras.metrics import MeanIoU
import segmentation_models as sm
sm.set_framework('tf.keras')
sm.framework()

from google.colab import drive
drive.mount('/content/drive')

"""##Function"""

def load_image(path, n_classes=3, SIZE_Y=512, SIZE_X=512):
  print('Loading in progress...')
  images_path = []
  images = []
  for directory_path in glob.glob(path):
      for img_path in glob.glob(os.path.join(directory_path, "*.png")):
          images_path.append(img_path)
  images_path.sort() #ให้เรียงลำดับรูปไม่ดึงมาแบบสุ่มๆ
  for img_path in images_path:
          img = cv2.imread(img_path, 1) #Read in BGR mode (1)      
          img = cv2.resize(img, (SIZE_Y, SIZE_X))
          #img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)#เปลี่ยน BGR เป็น RBG
          #img = img/255 
          images.append(img)
  images = np.array(images) #Change it to numpy array
  print('Done!')
  print(f'Images shape: {images.shape}\n')
  return images

def load_mask(path, n_classes=3, SIZE_Y=512, SIZE_X=512):
  print('Loading in progress...')
  masks_path = []
  masks = []
  for directory_path in glob.glob(path):
    for mask_path in glob.glob(os.path.join(directory_path, "*.tiff")):
        masks_path.append(mask_path)
  masks_path.sort()
  for mask_path in masks_path:
        mask = cv2.imread(mask_path, 0) #Read in grayscale mode (0)       
        mask = cv2.resize(mask, (SIZE_Y, SIZE_X), interpolation = cv2.INTER_NEAREST)  #Otherwise ground truth changes due to interpolation
        masks.append(mask)
  masks = np.array(masks) #Change it to numpy array
  #Encode
  labelencoder = LabelEncoder()
  n, h, w = masks.shape
  masks_reshaped = masks.reshape(-1,1)
  masks_reshaped_encoded = labelencoder.fit_transform(masks_reshaped)
  masks_encoded_original_shape = masks_reshaped_encoded.reshape(n, h, w)
  #Expand dimension
  masks_input = np.expand_dims(masks_encoded_original_shape, axis = 3)
  #One hot encode
  onehot_mask = to_categorical(masks_input,num_classes=n_classes)
  print('Done!!')
  print(f'Mask shape: {masks.shape}\n')
  return onehot_mask

def dice_cal(y_true, y_pred):
    intersection = np.sum(np.logical_and(y_true, y_pred).astype(float))
    if (np.sum(y_true)==0) and (np.sum(y_pred)==0):
        return 1
    return (2*intersection) / (np.sum(y_true) + np.sum(y_pred))

def Overall_Dice(images,mask,model,class_dict,BACKBONE,n_classes=3):

  dice_class_0 = []
  dice_class_1 = []
  dice_class_2 = []
  
  for img_num in range(len(images)):
    preprocess_input = sm.get_preprocessing(BACKBONE)
    img = images[img_num]  
    img_input = np.expand_dims(img, 0)
    img_input = preprocess_input(img_input)
    y_pred = model.predict(img_input)
    y_pred_argmax = np.argmax(y_pred, axis=3)[0,:,:]
    onehot_y_pred = to_categorical(y_pred_argmax,num_classes=n_classes)
    for i in range(n_classes):
      if i == 0:
        dice = dice_cal(mask[img_num][:,:,i], onehot_y_pred[:,:,i])
        dice_class_0.append(dice)
      elif i == 1:
        dice = dice_cal(mask[img_num][:,:,i], onehot_y_pred[:,:,i]) #ถ้่า channel ไม่ตรงกับ mask แต่ถ้าตรงไม่ต้อง +1
        dice_class_1.append(dice)
      elif i == 2:
        dice = dice_cal(mask[img_num][:,:,i], onehot_y_pred[:,:,i]) #ถ้่า channel ไม่ตรงกับ mask แต่ถ้าตรงไม่ต้อง -1
        dice_class_2.append(dice)
    
  print('\033[1mOverall Dice Score\033[0m')
  mean_dice_class_0 = np.sum(dice_class_0)/len(images)
  mean_dice_class_1 = np.sum(dice_class_1)/len(images)
  mean_dice_class_2 = np.sum(dice_class_2)/len(images)
  overall_dice = (mean_dice_class_0 + mean_dice_class_1 + mean_dice_class_2)/n_classes
  print(f'{class_dict[0]}: {round(mean_dice_class_0,3)}')
  print(f'{class_dict[1]}: {round(mean_dice_class_1,3)}')
  print(f'{class_dict[2]}: {round(mean_dice_class_2,3)}')
  print(f'All classes: {round(overall_dice,3)}\n')

def predict_on_image(img_path,model,BACKBONE,SIZE_Y=512, SIZE_X=512):
  preprocess_input = sm.get_preprocessing(BACKBONE)
  img = cv2.imread(img_path, 1) #Read in BGR mode (1)      
  img = cv2.resize(img, (SIZE_Y, SIZE_X))
  img_input = np.expand_dims(img, 0)
  img_input = preprocess_input(img_input)
  y_pred = model.predict(img_input)
  y_pred_argmax = np.argmax(y_pred, axis=3)[0,:,:]
  plt.figure(figsize=(12, 8))
  plt.subplot(121)
  plt.title('Image')
  plt.imshow(img)
  plt.axis('off')
  plt.subplot(122)
  plt.title('Prediction')
  plt.imshow(y_pred_argmax)
  plt.axis('off')

def see_image_mask_predict(images_batch,mask_batch,model,BACKBONE,img_num=0):
    preprocess_input = sm.get_preprocessing(BACKBONE)
    img = images_batch[img_num]

    img_input = np.expand_dims(img, 0)
    img_input = preprocess_input(img_input)

    y_pred = model(img_input)
    y_pred_argmax = np.argmax(y_pred, axis=3)[0,:,:]

    plt.figure(figsize=(12, 8))
    plt.subplot(231)
    plt.title('Image')
    plt.imshow(img)
    plt.axis('off')
    plt.subplot(232)
    plt.title('Mask')
    plt.imshow(np.argmax(mask_batch, axis=3)[img_num,:,:])
    plt.axis('off')
    plt.subplot(233)
    plt.title('Prediction')
    plt.imshow(y_pred_argmax)
    plt.axis('off')

def majority(h1,h2,h3,img_num=0):
  for i in range(3):
    if i == 0:
      h1orh2 = np.logical_or(h1[img_num][:,:,i], h2[img_num][:,:,i]).astype(float)
      h1orh3 = np.logical_or(h1[img_num][:,:,i], h3[img_num][:,:,i]).astype(float)
      h2orh3 = np.logical_or(h2[img_num][:,:,i], h3[img_num][:,:,i]).astype(float)
      and1 = np.logical_and(h1orh2, h1orh3).astype(float)
      gt = np.logical_and(h2orh3, and1).astype(float)
    else:
      h1orh2 = np.logical_or(h1[img_num][:,:,i], h2[img_num][:,:,i]).astype(float)
      h1orh3 = np.logical_or(h1[img_num][:,:,i], h3[img_num][:,:,i]).astype(float)
      h2orh3 = np.logical_or(h2[img_num][:,:,i], h3[img_num][:,:,i]).astype(float)
      and1 = np.logical_and(h1orh2, h1orh3).astype(float)
      and2 = np.logical_and(h2orh3, and1).astype(float)
      gt = np.dstack((gt, and2))
  return gt

def create_gt(h1,h2,h3):
  print('Processing...')
  for img_num in range(len(h1)):
    if img_num == 0:
      gt = majority(h1,h2,h3,img_num=img_num)
    elif img_num == 1:
      gt_inter = majority(h1,h2,h3,img_num=img_num)
      gt = np.stack((gt, gt_inter))
    else:
      gt_inter = majority(h1,h2,h3,img_num=img_num)
      gt_inter = np.expand_dims(gt_inter, axis = 0)
      gt = np.concatenate((gt, gt_inter))
  print('Done!')
  print(f'GT shape: {gt.shape}')
  return gt

"""##Action"""

model_path = '/content/drive/Shareddrives/CXR_Project/Code/Colab_Notebook/Full Inspired/NEW_MODEL_UNET/SAVED_MODEL/ribmodel_resnet50_2450_e100_b4_lr0.0001.hdf5'
test_image_path = '/content/drive/Shareddrives/CXR_Project/Code/Colab_Notebook/Full Inspired/NEW_MODEL_UNET/IMAGE_TEST_200'
h1_path = '/content/drive/Shareddrives/CXR_Project/Code/Colab_Notebook/Full Inspired/NEW_MODEL_UNET/MASK_GT_TEST/mask by earn/Rib'
h2_path = '/content/drive/Shareddrives/CXR_Project/Code/Colab_Notebook/Full Inspired/NEW_MODEL_UNET/MASK_GT_TEST/mask by myu/Rib'
h3_path = '/content/drive/Shareddrives/CXR_Project/Code/Colab_Notebook/Full Inspired/NEW_MODEL_UNET/MASK_GT_TEST/mask by boo/Rib'

model = tf.keras.models.load_model(model_path, compile=False)

BACKBONE = 'resnet50'

images = load_image(test_image_path)

h1 = load_mask(h1_path)
h2 = load_mask(h2_path)
h3 = load_mask(h3_path)

gt = create_gt(h1,h2,h3)

n_classes = 3
for i in range(n_classes):
  plt.figure(figsize=(3,3))
  plt.imshow(gt[0][:,:,i], cmap='gray')
  plt.title(i)

class_dict = {0:'BG', 1:'Lt_rib', 2:'Rt_rib'}

Overall_Dice(images,gt,model,class_dict,BACKBONE,n_classes=3)

"""* Show all prediction"""

for i in range(200): #ถ้าจะดูทั้งหมดเปลี่ยน 5 เป็น len(image)
  see_image_mask_predict(images_batch = images,
                        mask_batch = gt,
                        model = model,
                        BACKBONE = BACKBONE,
                        img_num = i)

"""* Show one prediction"""

img_path = '/content/drive/Shareddrives/CXR_Project/Code/Colab_Notebook/Full Inspired/Lung_Rib_Dataset/RIB/train_raw_data/train1/image/1.jpeg'

predict_on_image(img_path,model,BACKBONE)